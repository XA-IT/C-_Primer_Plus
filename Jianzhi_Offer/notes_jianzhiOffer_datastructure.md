# 剑指Offer
## 面试需要的基础知识
### 编程语言基础  
### C++  
- 面试题1：赋值运算符函数  
    - 传参 常量 **引用**；返回值为自身的引用(`*this`)；释放已有内存；判定当前实例是否与传参相同  
    - 测试用例：将一个实例赋值给另一实例； **赋值给自己** ；连续赋值；
    - 考虑 **异常安全性**，通过创建临时实例实现兑换，使用自身析构函数执行内存释放。  

### 数据结构  
#### 数组  
- 连续内存；按序分配存储；时间效率高O(1)；空间效率低（改进：动态数组vector）  
- 面试题3：二维数组中的查找  
    - 从具体情况入手；考虑更简单的选择方法；找出规律；

#### 字符串  
- 字符串以'\0'结尾  
- 面试题4：字符串替换
    - 注意到时间效率的提升，由于替换增加了字符，需要考虑到长度的变化，以及后续字符串后移，可以先整体计算需要移动的位数再 **自后向前** 替换；
    - 对于需要移动序列的操作，应该考虑从头还是从尾部开始  

#### 链表
- 动态数据结构；空间效率更高；
- 面试题5：倒序打印链表
    - 使用栈操作  
    - 递归实现（可能导致溢出）

#### 树  
- 面试题6：根据前序和中序遍历队列输出原二叉树
    - 注意可能的 *exception*，考虑try 以及 catch/ throw语句，如找不到父节点、两序列长度不匹配等  
    - 输入：两序列的首节点地址，序列长度等  
    - 考虑迭代算法，递归调用输出左右子树  
- 面试题41: 数据流中的中位数
  - **AVL树**:
    - 见 [cpp文件](AVL_tree.cpp)
  - **最大堆**:
    - 通过分割为左右两部分寻找最大和最小的两个数
    - 使用STL中的`make_heap(b, e);`, `pop_heap();`, `push_heap(T)
##### 红黑树
- **红黑树的特点**
    1. 所有节点非黑即红
    2. 根节点为黑
    3. 叶节点为黑(专指为**空**的叶节点)
    4. 红色节点的子节点必为黑
    5. 从一个节点到其所有子孙节点的路径上必须都包含相同数量的黑色节点  -->  没有一条路径会比另一条长出两倍以上, 保证接近平衡
- **红黑树的操作:** 
  - **旋转**: 为了在添加或删除节点后仍满足如上五条性质, 需要进行旋转操作如下:
    1. 左旋: 原父节点更新为其右子节点的左节点, 被替换的节点成为原父节点的右节点(维持大小关系)
    2. 右旋: 原父节点更新为其左子节点的右节点, 被替换的节点成为原父节点的左节点
  - **插入**: 对于插入操作, 满足查找树的特性, 且首先着色为红, 故不会影响特性1235, 对于插入节点的父节点是**红色**的情况, 需要旋转迭代将父节点的红色传递到根节点, 再将根节点染黑, 以满足4  
  


#### 栈和队列
- 面试题7：用两个栈实现队列  
    - 抽象问题具体化，考虑实际流程

### 算法与数据操作
#### 查找&排序
- 在并未专门考察排序时使用STL中的sort函数即可实现；
- 快速排序
    - 选择序列中一个数a，放至队尾；使用两个指针b，c从头部以及头部-1处开始于之对比，b指向的比a小则移动c，交换bc指向的数；一个用来依次指向本次对比对象，另一个用于记录位置，确保其左边全部比a小。  
	- 旋转数列，二分查找，从中间开始，对比与首尾的关系进行查找，需要考虑大于、等于、小于的特殊情况；

#### 递归与循环
- 斐波那契数列

#### 位运算
- 右移位运算 用符号位填充（可能为0或1）因此左移（用0填充）更为安全；尽量用**右移**位运算代替除法，33/32 等价于 `33>>5` , 用**按位与**代替求余；
- 一个性质：一个整数-1后 与原整数按位与，会使整数中最右的1变为0，如12-1=1100-1=1011,1100&1011=1000；
- 使用按位与运算代替`2^n`的求余运算, 尤其当需要判断奇偶数的时候(&1)
  - a%32 等价于 a&31(0x1f)

#### 链表
- 删除一个给定的节点: 如果已知节点, 无需遍历到该节点以获取前一节点的信息, 可以将下一节点的值在该节点上**覆盖**
	
	
	
	
	
	
