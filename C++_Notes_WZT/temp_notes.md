## C++ general learning
C++清华：https://www.bilibili.com/video/av20786390
《C++ Primer（第5版）》
### 数据、表达式
#### 变量和基本类型
- 引用 *（primer）* 
  - 即 **对象** 别名，需与绑定对象类型严格匹配
  - 例外： 常量引用，初始化时会将右侧类型进行转换
- void* 指针
  - 仅仅是地址值，不能操作指向的数据
  - 可用static_cast< >强制转换
- const 与 constexpr
  - 编译时就能 **计算结果** 的表达式
  - 顶层const：指针本身为常量
  - 见constexpr函数
- 别名
  - `typedef double wages; //定义wages为double的别名`
  - `C++11: using SI = Sales_item; //定义SI为Sales_item别名`
  - 注意！`typedef char* pstring; //是指针的别名` >> `const pstring cstr = 0; //表示一个常量指针而非指向const char的指针`
- auto 与 decltype
  - auto 会忽略掉顶层const，但保留底层const
  - decltype((变量))将会返回变量的引用，因此必须初始化，对于变量为解引用操作同样需要初始化

#### 数据类型的转换
- 算术类型转换
  - 赋值语句中，右侧类型被转换为左侧的
  - 将小整数类型转换为更宽的整数类型
    - 列表初始化中，若左值空间不足编译器将会报错
  - 将有符号类型转换为无符号类型（注意！：比较运算等也会进行转换）
- 其他隐式转换
  - 数组转化为指针
  - 指针的转换（NULL, nullptr, void*等）
  - 其他
- 显式转换
  - !!一种**危险**的操作
  - static_cast
    - 将宽精度类型赋值给较小类型
    - void*指针类型转换为指定类型
  - const_cast
    - 去掉const性质
    - 常用于函数重载中
  - reinterpret_cast
  - dynamic_cast

#### 表达式
- if else 与 switch case
  - case标签须为整型常量表达式，可以多个case执行相同语句
  - 若要在case内定义新的变量，需要定义在块{}内，限定作用域
- try与异常处理
  - `throw表达式` 异常检测 `throw exception-declaration(一个string / c风格字符串用于初始化)`
  - `try语句块` 尝试处理异常
  - 异常类`exception class`用于传递具体异常信息
    ```
    try {
      program-statements
    } catch (exception-declaration) {
      handler-statements
    } //...
    ```
  - 标准异常\<stdexcept>定义的异常类
    - exception 需默认初始化，其他如`runtime_error` `range_error` 等需用string或字符串初始化
    - 异常类型只定义一个`what()`函数，返回一个异常信息（字符串）
 
### 函数
#### 含有可变参数的函数
- 所有实参类型相同，使用`initializer_list<T> lst;`模板初始化，<T>表元素类型，对象元素永远为常量值
- 类型不同，使用可变参数模板
#### 内联函数
- 不能含有循环与switch语句
- 定义需在调用之前
- 不能进行异常接口声明
#### constexpr函数（C++11） 与constexpr类型
- 由编译器校验是否为常量表达式
- 仅能用于字面值类型， 对于指针，constexpr表示常量指针，为顶层const

### 类
#### 类的设计
- “合法值”是什么
- 具有何种功能？ 函数、操作符
- 如何被创建与销毁
- 如何对对象进行初始化与赋值
- 如何作为参数传递
- 谁可以使用？权限？
#### 类的成员
- public
- private
- protected
#### 类的构造函数
- 无返回类型，仅在创建对象时调用
- 默认构造函数 `Clock();` ； 强制使用默认构造函数 e.g. `Clock() =default;`  
- 初始化列表的使用（比在构造函数中实现更简洁）： 
  ```
  Clock::Clock(int newH, int newM):
    hour(newH), minute(newM){          
    } 
  ```
- 委托构造函数
  - `Clock(): Clock(0, 0){}`
- 拷贝构造函数
  - 使用本类对象的const **引用**来拷贝初始化
  - 调用的情景
    - 以本类另一对象初始化
    - 函数中形参使用实参来初始化
    - 返回一个对象时发生拷贝
  - 不希望被拷贝构造：
    - C++98: 将函数声明为private
    - C++11: `Clock() =delete;`
#### 析构函数
- 用于删除对象，进行处理
- `~类名()` 参数表和返回值均为空
#### 类的组合
- 用其他类的对象作为成员
- 在构造函数中需要对 对象成员进行初始化，形式：`类名::类名(对象成员形参，本类成员形参: 对象1(参数), 对象2(参数)) ...{}` 
- 在构造函数中 顺序按照定义顺序，未给出的执行默认构造函数，先初始化再进入函数体
- 组合类构造完成后，临时对象被析构，组合类析构时，先析构自身，再依次析构组合的对象成员，析构顺序相反
#### 前向引用声明
- 在使用前先声明引用类
- 只能使用符号，不能使用其作为对象或内联函数
#### **结构体**
- 数据成员默认为公有，用于保存数据
- 可以有函数成员
#### 枚举类
- C++11： `enum class 枚举类型名: 底层类型(默认为int){枚举值列表}`
- 优势：
  - 强作用域，限制枚举值的作用域
  - 转换限制（无法比较）
  - 可以指定底层类型

### 数据的共享与保护
#### 作用域
- 局部作用域
- 类作用域
- 文件作用域
- 可见性
  - 同名变量会屏蔽外层变量
#### 生存期
- 静态 `static`
  - e.g. 在函数中再次调用时不再初始化static 变量
- 动态
#### 类的静态数据成员
- 定义、初始化在类体外
#### 静态函数成员
- 处理整个类的静态数据成员 `static void showCount();`
- 一般不处理具体对象的数据；
#### 友元
- 友元函数 & 友元类
- 友元关系为单向的
#### 对数据的保护——常量
- 常对象
- 常成员
  - 常成员函数： `类型说明符 函数名(参数表) const` 
  - 保证不改变对象状态
- 常引用
  - 只读的引用
#### 多文件的结构与编译预处理
- 外部变量 `extern` 具有文件作用域
- **标准C++库**：
  - 输入输出类
  - 容器类与抽象数据类型
  - 存储管理类
  - 算法
  - 错误处理
  - 运行环境支持

### 数组、指针
#### 数组
- `类型 数组名[常量表达式][常量表达式]`
- 数组名为常量，标志首元素的内存地址
  - 在索引时可以用指针变量代替数组名称，对于内置类型（非vector、string类的stl类型）索引甚至可以为负，只要指向位置合法
    - `int (*p)[4] = ia;` p为指向一个含有四个元素的数组的指针，括号**不可省略**，否则意为元素为指针的数组
- 二维数组可以只对部分元素初始化，第一维下表数可以省略
  - `static int a[][4] = {{1,2},{1,2,3,4},{12}};`
- 作为参数传入函数时，传的是首地址，因此原始数组是可被函数修改的
- 对象数组
  - 对象被依次构造和析构，无初始参数时执行默认初始化
- C++11：基于范围的for循环
  - `for(int & e: array) {}`
- vector类型
  - 一个类模板 -> 在实例化时由<对象类型>决定内容
  - C++11: 允许vector中元素为vector时不用空格`vector<vector<int> >`空格可省
  - C++11: 允许列表初始化（与枚举中类似）
    - 列表初始化：
  - vector 允许拷贝赋值，而数组在C++中本身不允许！
- 迭代器
  - 对容器类型的间接访问，与指针类似
  - 通过v.begin() 与v.end() (尾后指针)
  - C++11: cbegin() 与 cend()，表示只读型迭代器
  - 使用迭代器的for循环中应避免改变元素的数量
  - 数组可以用指针指向尾后实现迭代器
    - C++11: `int *beg = begin(ia);` ia为数组
#### 指针
- 初始化 `存储类型 数据类型 *指针名 = 初始地址;`
- 赋值 注意数据类型相符
  - void类型指针 只能存放地址，不能用于访问，须转换；`void *pv = &i; int *pint = static_cast<int*>(pv);`
- 空指针 `NULL`, `nullptr`
- ++与--运算：指向下一个或者前一个元素
  - C++11: 指针相减得到距离，类型为`ptrdiff_t`，有符号
- 指向 **数组元素** 的指针：
  - `int a[10], *pa;`  `pa = a;`
  - `a[i], *(pa+i), *(a+i), pa[i]`均为等效
- 使用指针作为参数
- 指针类型的函数
  - 不能返回非静态局部地址
  - 可以返回在调用前就已分配的地址
  - 也可以返回动态内存分配获得的地址，但需要注意释放
- 指向 **函数** 的指针
  - `存储类型 数据类型 (*函数指针名)();`
  - 函数回调 将函数指针作为参数传递
  - e.g. `int compute(int a, int b, int(*func)(int, int)) {return func(a, b);}`
- 指向对象的指针
  - `ptr->getx();`等价于`(*ptr).getx();`
  - `*this`指针
- 6-12-1

#### 表达式
- 重载运算符
  - 用于类类型的运算对象
- 左值与右值
  - 左值lvalue：对象的身份（在内存的位置）
  - 右值rvalue：对象的值（内容）
  - decltype求得左值类型时返回一个引用
- 取余运算
  - C++11中认为对于正整数m,n, `m%(-n)`结果为`m%n`
- 赋值运算满足右结合律，可以对同类型进行连续赋值
- 适当混用运算符 e.g. `cout << *pbeg++;` 等效于 `cout << *(pbeg); ++pbeg;`
  - 但需要注意若等号右侧修改了数据的值后再进行的运算可能是未定义的
- 条件运算符
  - `cond? expr1 : expr2;`
- sizeof 运算符
  - 右结合律，参数为指针时可为无效指针
  - C++11: 可以通过类的作用域运算符求得结果
  - 对数组运算会返回整个数组大小