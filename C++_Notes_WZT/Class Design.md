## Part Ⅲ Tools for Class Designer
C++ Primer 5th edition

---

### Cpt.13 **拷贝控制**
定义对象在拷贝/移动/赋值/销毁时的行为:
- 拷贝构造函数; 拷贝赋值运算符; 移动构造函数; 移动赋值运算符; 析构函数

#### 拷贝/赋值与销毁
- 拷贝构造函数
  - 第一个参数为自身类类型的引用, 且其他参数有默认值的构造函数, 绝大多数情况为const引用
    - 在多种情况下都可能使用, 因此不宜为`explicit`的
  - 合成拷贝构造函数:
    - 为内置类型成员直接拷贝, 为类类型的成员调用该类的拷贝构造函数; 其中数组也可以被依次将其中元素拷贝
  - 拷贝初始化的场景:
    - 赋值(=); 非引用的参数传递与返回(因此函数本身必为引用传参); 使用初始化列表初始化数组或聚合类
  - 限制
    - 当构造函数本身被`explicit`限制时, 赋值/传参等语句将不能隐式转换类型, 因此不能期待通过拷贝构造函数进行类型转换: `vector<int> v2 = 10;` // 错误
  - 编译器被允许绕过拷贝构造函数, 但该函数必须存在且可访问
- 拷贝赋值运算符
  - 重载赋值运算符: 名为`operator=`的函数
  - 合成拷贝赋值运算符: 编译器自行合成; 也可用于禁止该类对象的赋值
- 析构函数
  - 析构函数是唯一的, 无返回值, 不接受参数
    - 析构函数首先执行函数体, 随后以初始化顺序的逆序销毁成员
    - 智能指针是一个类类型, 因此析构阶段会被销毁
  - 析构函数的**调用时间**
    - 变量离开作用域; 一个对象被销毁; 容器被销毁时, 元素被销毁; 对动态分配的对象, delete指向它的指针时; 对于临时对象, 创建它的表达式结束时销毁; 
  - 合成析构函数: 一般为空; 除非为阻止销毁
  - 注意: 析构函数体 != 成员销毁, 销毁是在函数体执行完成后另外执行的
- 三/五法则
  - 最好以一个整体定义以上的函数; 
  - 需要析构函数的类也需要拷贝和赋值操作
    - 需要析构往往需要释放内存, 不定义拷贝函数将导致内存可能被释放两次
  - 需要拷贝的类也需要赋值操作
- 声明使用合成版本的构造或拷贝控制函数: `=default`
  - `~Sales_data() = default;`
  - `Sales_data& Sales_data::operator=(const Sales_data&) = default;` //此处是在类外进行的声明
  - 如果不希望定义为内联形式的, 需在类外定义中加上=default
- 阻止拷贝
  - 定义删除的函数
    - 在声明后加 `= delete`, 告知编译器不希望定义此类成员:
      - `NoCopy(const NoCopy&) = delete;`
    - 必须在首次声明时即添加
    - 可以对任意函数指定=delete
  - 析构函数不能为删除的成员
    - 对于这类类型编译器将禁止定义, 但可以使用动态分配来构造, 但不能通过指针释放
  - 合成的拷贝控制成员可以是删除的
    - 对于一个类有数据成员不能默认构造/拷贝/赋值或销毁, 则对应成员函数被定义为删除的
  - **非C++11** 的方法
    - private拷贝控制; 但应使用新方法

#### 拷贝控制和资源管理
需要**管理类外资源**的类必须定义拷贝控制成员, 而拷贝的语义一般分为行为**像**值或指针两种, 对于无法归类到这两种动作的类型, 如IO类型和unique_str, 不允许拷贝或赋值
- 行为像值的类
  - 拷贝构造函数: 申请新的空间, 值与拷贝对象的成员的值相同
  - 拷贝赋值运算符: 重新申请新的空间, 值与拷贝对象相同, 然后**再释放旧的空间**, 将指针指向新空间; 也就是需组合析构函数的工作, 同时避免提前释放造成**自赋值时错误**!
  - 析构函数: 释放空间
- 行为像指针的类
  - 需要管理的是指针本身而非它指向的对象, 因此不应单方面释放其指向的空间; 因此更适用于 智能指针, 或使用自己的 **引用计数**
  - *引用计数*
    - 初始化对象时创建一个引用计数(除拷贝构造)
    - 拷贝构造函数递增共享的计数器
    - 析构函数递减计数器
    - 拷贝赋值运算符递增右侧对象的计数器, 递减左侧对象的, 当为0时**执行销毁**
    - 存储位置: 为保证所有拷贝/引用了对象的计数器均同步, 应放在动态内存中

#### 交换操作
定义`swap()`函数
对于行为像值的类, 交换时并不需要申请额外的空间, 只需要交换指针, 因此需要定义自己的swap函数.
- swap函数应调用swap而非std::swap(), 否则并未节省空间
  ```cpp
  void swap(HasPtr &lhs, HasPtr &rhs) {
      using std::swap;
      // 此处使用using是说明仅重载以下类型的形参
      swap(lhs.ps, rhs.ps);
  }
  ``` 
- 使用拷贝和交换来定义赋值:
  ```cpp
  HasPtr& HasPtr::operator=(HasPtr rhs) {
    swap(*this, rhs);   //由于传递的是值, 进行了形参拷贝, 同时在交换后自动销毁了原副本
    return *this;
  }

#### 拷贝控制示例
不需要控制资源分配的类也可能需要拷贝控制成员

#### 动态内存管理类
- 实现一个类似于`vector<string>`的类`StrVec`
  - 主要数据成员: 
    - elements, 分配的内存的首元素
    - first_free
    - cap, 指向分配内存末尾之后的位置
    - 静态成员`alloc`: 一个`allocator<string>`
  - 主要成员函数:
    - `alloc_n_copy`: 分配内存并拷贝n个元素进去
    - `free` 销毁构造的元素, 释放内存
    - `chk_n_alloc`: 保证`StrVec`对象有至少一个新元素的空间, 否则reallocate分配新内存
    - `reallocate`  
    [实现文件](tryit/cpp_primer_13_39_1.cpp) 
  - 关于`reallocate`:
    - 拷贝操作是多余的, 因为拷贝完成后不再会使用原数据, 这种操作被专门称为**移动**, 因此有专门的移动构造函数
    - C++11: `std::move()`

#### 对象移动
C++11: 移动对象而非拷贝以提升性能; 此外对于IO类或unique_ptr等包含不能共享的资源的类, 不能进行拷贝, 必须进行移动(因此旧版本容器中不能存储这种类型)
##### 右值引用 && 
- &&
  - 左值使用的是对象的身份, 右值使用的是对象的值本身
  - 常规引用也可称为左值引用, 只能绑定左值, 而右值引用相反, 右值引用只能绑定**临时对象**
- 左值持久; 右值短暂
  - 右值的特性: 1. 所引用的对象即将被销毁; 2. 该对象没有其他用户.
- 变量是左值, 不能将变量表达式绑定为右值引用
- 标准库的`move`函数
  - 定义在`<utility>`头文件中
  - 获得绑定到左值上的右值引用: 
    ```cpp
    int && rr1 = 42;
    int && rr2 = rr1;   // 错误! rr1本身为左值
    int && rr3 = std::move(rr1);    // ok
    ```
  - 最好使用`std::move()`避免潜在的冲突, 使用其就意味着我们将不能在使用移后原对象的值

##### 移动构造函数和移动赋值运算符
- 类的移动构造函数
  - 类似于拷贝构造函数, 任何除了第一个引用外的参数必须有默认实参
```cpp
StrVec::StrVec(StrVec &&s) noexcept:    // 移动构造函数本身不应抛出任何异常
               elements(s.elements), first_free(s.first_free), 
               cap(s.cap) {
    s.elements = s.first_free = s.cap = nullptr;
}     // 最后移后源对象会被销毁(立即进入可析构的状态), 因此我们需要先重置s.first_free, 否则会释放刚移动的内存
```
- 移动操作, stl容器和异常
  - 由于移动操作本身不分配任何资源, 因此不会抛出异常, 需要通知标准库
    - C++11: 使用`noexcept`来通知, 必须在**声明和定义**中都进行指定
    - 对于如vector的容器来说, 它保证如果调用`push_back`时出现异常其自身**不会发生改变**, 因此如果没有`noexcept`的声明这一特性将无法保证, 从而使得这些容器只能调用拷贝构造
- 移动赋值运算符
  ```cpp
  StrVec& StrVec::operator=(const &&rhs) noexcept {
      if (this != &rhs) {
          free();
          elements = rhs.elements; first_free = rhs.first_free;
          cap = rhs.cap;
          rhs.elements = rhs.first_free = rhs.cap = nullptr;
      }
      return *this;
  }
  ```
  注意: 必须要检查**是否为自赋值**的情况, 否则将会在赋值前释放自身
- 移后源对象必须可析构
  - 移后源对象必须保证**有效的, 可析构的**状态, 
  - 对象随时可以被析构, 不再被别处使用, 用户可以继续赋新值, 但不能对其现有值有任何假设; (需要考虑到类的具体实现)
- 合成的移动操作
  - 只有一个类没有定义任何自己版本的拷贝控制成员, 且所有非static成员都可以移动时, 编译器才会合成
  - 移动操作永远不会隐式定义为删除的函数, 除了显示地要求生成`=default`但无法生成时(如成员缺少移动操作, 或类成员自己定义了拷贝操作而未定义移动操作)
  - 其原则与合成拷贝操作的原则类似
  - 如果定义了移动操作(构造或赋值)将会使合成的拷贝操作(构造或赋值)变为**删除的**
- 在程序中编译器将根据函数匹配规则来选择拷贝或移动
  - 移动右值(如果定义了移动操作), 拷贝左值
  ```cpp
  class HasPtr {
    HasPtr(HasPtr &&p) noexcept: ps(p.ps), i(p.i) { p.ps = 0; }
    // 注意: 赋值运算按值传递参数, 根据类型自行调用拷贝与移动构造函数
    HasPtr& operator=(HasPtr rhs) 
    { swap(*this, rhs); return *this; }
  }
  ``` 
  - **更新的三五法则**
    - 一个类如果定义了任何一个拷贝操作, 它就应该定义全部五个操作: 拷贝构造, 拷贝赋值, 移动构造, 移动赋值, 析构
  - 移动迭代器
    - 对于移动迭代器的解引用将返回一个右值
    - 可以用于构造分配新内存时
  - 右值和左值引用成员函数
    - 有时右值可能被允许赋值: `s1 + s2 = "wow!";` //此处 = 左边是一个右值
    - 为**强制**运算对象为左值, 可在参数列表后放置一个**引用限定符**:
      `Foo &operator=(const Foo&) &;` // 引用限定符可以为&或&&, 只能用于(非static)成员函数, 且需同时在声明和定义中出现, 若同时有const限定符, &须在const之后 
  - 拥有引用限定符的函数可以被重载
    - 如果定义了一个拥有限定符的函数, 其其他重载版本均需要加上引用限定符



### Cpt.14 **重载运算与类型转换**
重载的运算符是具有特殊名字的函数, 其名字由关键字**operator**和其后要定义的运算符号组成.
#### 基本概念
- 对于二元运算符, 将左侧对象传递给第一个参数, 右侧给第二个, 对于成员运算符函数, 左侧运算对象为this指针
- 不能对内置类型进行重载: `int operator+(int, int);` //错误!
- 不能创建新的运算符
- 直接调用运算符函数: `operator+(data1, data2);` 等价于 `data1 + data2;`; `data1.operator+=(data2)` 等价于 `data1 += data2;`
- 重载的运算符含义应该与内置类型一致
- 对于赋值/下标/调用等运算符可以设为成员函数, 但对于算数/相等性/关系/位运算等应该设为非成员函数:
  - `string u = "hi" + s;` //若为成员函数则错误, `const char* `类型没有成员函数`operator+`!
#### 输入和输出运算符
- 必须为非成员函数
- 对输出运算符的重载
  - 输入为ostream的引用 以及 输入对象的常引用; 返回为os 的引用, 左侧运算符被绑定在os上
    `ostream& operator<<(ostream &os, const Sales_data &item);`
  - 尽量减少格式化操作, 避免自行换行等操作
  - 运算符必须为非成员函数
- 对输入运算符的重载
  - 注意检查输入istream & is的错误: (见Cpt.08)
    - 在使用输入数据前进行判断: `if (is) { ... }`
  - 发生错误后及时将操作对象重置为空(调用默认构造函数)
#### 算术和关系运算符
- 非成员函数, 传入常量引用
- 如果定义了复合运算符, 更应在实现中调用之(如 += 实现 + ), 这样可以减小拷贝次数
- 如果定义了相等运算符(==), 则应定义不等运算(!=)
- 如果定义了关系运算符(<), 则对于两个!=的对象应该有一个 < 另一个
#### 赋值运算符
- 必须为成员函数, 可以定义其他类型作为rhs, 如`std::initializer_list<T>`
- 注意释放当前内存空间, 并创建新空间(若为本类型一定要检验**自赋值**的情况)
- 一般需为成员函数, 返回运算符左侧的对象的引用: *this
#### 下标运算符operator[]
- 必须为成员函数, 返回访问元素的引用, 且应有普通和const两个版本
- `const string& operator[](sizt_t n) const { return elements[n]; }`
#### 递增和递减运算符++, --
- 应为成员函数, 返回对象的引用, 且应有前置和后置两个版本
- 前置: `StrBlobPtr& operator++ ();`
- 后置: `StrBlobPtr operator++ (int);`, 形参仅用于区分前置, 不参与运算, 返回原值, 而非修改后的引用
  - // 注意应先记录当前对象值, 自增后返回增加前的值
  - 后置应调用前置的版本
  - 若想显式地调用后置运算符, 需传入形参: `strblobp.operator++(0);`
#### 成员访问运算符
- 成员函数, 返回对应的引用(*)或地址(->)
- 箭头运算符必须实现成员访问的功能
  - `point->mem`等价于`point.operator()->mem;`
#### 函数调用运算符: 使对象可以作为函数进行调用
- 注意是调用一个对象, 而非直接调用类型
- 必须为成员函数, 定义了函数调用运算符的对象为 函数对象
##### 常用作泛型算法的实参: (类的未命名对象)
    ```cpp
    class PrintString {
    public:
        PrintString(ostream &os = cerr, char c = ' '): os(o), sep(c) { }
        void operator() (const string &s) const { os << s << sep; }
    private:
        ostream &os;  
        char sep;
    }      
    for_each(vs.begin(), vs.end(), PrintString(cerr, '\n'));  
    ```
- lambda是函数对象(未命名类的未命名对象)
  - 其值捕获相当于在类中以对应数量的数据成员进行初始化, 但该合成类将不具有默认构造函数等
##### 标准库定义的函数对象
  - 定义了一组模板类, 如下所示
  - **头文件**: `<functional>`
- 定义成模板的形式, 如`plus<string> strAdd;`实现对string的加法
    |         算术         |         关系         |        逻辑         |
    | :------------------: | :------------------: | :-----------------: |
    |     `plus<Type>`     |   `equla_to<Type>`   | `logical_and<Type>` |
    |    `minus<Type>`     | `not_equal_to<Type>` | `logical_or<Type>`  |
    |  `mulitplies<Type>`  |   `greater<Type>`    | `logical_not<Type>` |
    |   `以及divides, `    | `less, less_equal等` |
    | `modulus(%), negate` |
- 使用标准库函数对象: `sort(svec.begin(), svec.end(), greater<string>());`//降序排列, 注意函数调用运算符()
    - 甚至可以比较指针: 
    - `sort(nameTable.begin(), nameTable.end(), less<string *>());`//其中nameTable的元素为string *
    - 关联容器set和map中默认使用`less<key_type>`来对元素排序
##### 可调用对象与function
- 可调用对象: 函数/函数指针/lambda表达式/bind创建对象/重载函数调用运算符的类
- 可能共享相同的**调用形式**: 如`int(int, int)`表示接受两个int返回一个int
    ```cpp
    int add(int i, int j) { return i + j; }
    auto mod = [] (int i, int j) { return i % j; }
    struct divide {
        int operator() (int i, int j) {
            return i / j;
        }
    }   //分别定义了加法/取模/除法
    ```
    - 对于相同调用形式的可调用对象, 可以定义一个**函数表**(function table)用于存储指向这些对象的"指针", 可以通过`map`实现:
    - `map<string, int(*) (int, int)> binops;` //这里只能直接存放**函数指针**add, 对于其他形式的函数需要转换类型
- 标准库function类型
    - `function`的操作:
    - `function<T> f;` `function<T> f(obj);`// f存储可调用对象obj的副本
    - `f`//当f存储obj时为真, 为空时为假
    - `f(args)`// 调用f中的对象, 参数是args
    - `function<T>`的成员类型:
    - `result_type`, `argument_type`, `first_argument_type`, `second_argument_type`等
    - 创建具体的function类型: 
    - `function<int (int, int)> f2 = divide();`
    - 从而使`map`变为`map<string, function<int (int, int)>> binops;`
    - 对于重载过的函数不能直接放入function对象中, 因为无法通过名字来确定版本
        - 需要直接存储函数指针(`int (*fp) (int, int) = add;`)或lambda表达式来限定函数版本


---

### Cpt.15 **面向对象的程序设计**
#### OOP: 概述
- 继承
  - 派生类由基类通过继承得到, 基类定义在层次关系中的所有类共同拥有的成员
  - 对于需要派生类各自定义版本的函数需要被声明为**虚函数**
- 动态绑定(运行时绑定)
  - 实现类的多态, 使用基类的引用, 在运行时确定调用的函数版本
  - ..

#### 定义基类与派生类

##### 类型转换与继承
- 注意: 基类的指针或引用可以绑定在派生类上
- 静态类型与动态类型
  - 仅对于指针或引用, 会在运行时确定的为动态类型
- 不能从基类隐式转换为派生类